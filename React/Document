Here are some common features and patterns you might find in an ASP.NET Core API boilerplate:


" it includes a set of conventions and structures to organize code "

conventions   الاتفاقيات
structures البنية
kickstart ركلة بداية
well-organized منظمة تنظيما جيدا
concerns اهتمامات \مخاوف
Pre-configured تم تكوينها مسبقا
integrated دمج
capture متابعة /التقاط
common / شائعة - مشتركة
schemes مخطط
policies سياسات
gracefully ب رشاقة
integration اندماج
standardized approach  نهج موحد
proper مناسب سليم
meets specified criteria تفي ب ال



1. Project Structure:
A well-organized project structure that separates concerns, possibly following a modular architecture.
2. Dependency Injection:
Pre-configured dependency injection for managing and injecting services into controllers and other components.
3. Configuration:
Configuration setup for handling settings and environment-specific variables.
4. Logging:
Integrated logging to capture information, warnings, and errors.
5. Middleware:
Pre-configured middleware for handling common tasks such as exception handling, CORS, and authentication.
6. Authentication and Authorization:
Setup for common authentication schemes (JWT, OAuth, etc.) and authorization policies.
7. API Versioning:
Boilerplate for versioning your API gracefully.
8. Swagger/OpenAPI Integration:
Integration with Swagger or OpenAPI for automatic API documentation and testing.
9. Exception Handling:
A standardized approach for handling exceptions and returning consistent error responses.
10. Response Formatting:
- Standardized response formats, including proper use of HTTP status codes and response structures.
11. Model Validation:
- Pre-configured model validation to ensure incoming data meets specified criteria.
12. Unit Testing Setup:
- Boilerplate code for setting up unit tests, possibly using testing frameworks like xUnit or NUnit. ( xUnit, NUnit)
13. Entity Framework Core Setup:
- If the API interacts with a database, boilerplate code for setting up Entity Framework Core for data access.
14. Health Checks:
- Integration of health checks for monitoring the health of the API.
15. Request/Response Logging:
- Logging of incoming requests and outgoing responses for diagnostics.
16. Dockerfile:
- A Dockerfile for containerizing the API, making it easy to deploy in containerized environments.
17. Cross-Origin Resource Sharing (CORS) Configuration:
- Setup for handling cross-origin requests.
18. WebSockets and SignalR Configuration:
- If the API uses real-time communication, boilerplate code for setting up WebSockets or SignalR.
19. Repository Pattern (Optional):
- A common pattern for handling data access, often using a repository pattern.
20. ASP.NET Core Identity (Optional):
- If user authentication and authorization are needed, the boilerplate might include ASP.NET Core Identity or a custom authentication setup.
21. Integration with External Services (Optional):
- If the API interacts with external services (e.g., third-party APIs), there might be a placeholder or example code.
22. Caching Setup (Optional):
- If caching is required, boilerplate code for setting up caching mechanisms.

rafce > shortcat
paradigm 
observable state
straightforword
boilerplate نموذجي
Learning Curve
declarative 
Destructuring تدمير 


React  > library to build user interface UI
facebook , 2011 -> be stabel 2015 

benfits
1. SPA Single Page Application
2. Client Side Library
3. Build complex UI easy 
4. Component



declarative  , componenet , 
1.var , let, const
var : globale scope > define before declare
let : block scope  > reChange value 
const = block scope > !reChange value 

2. Arrow Function 
const sayGo =  _  => c.l("go");
const say=  _  =>  2;
const sayMyName =  (name)  => c.l(name);

3. Export and Import
//fileName.js
export defult func;

//mainApp.jc
import func from './fileName.js'

if export multi func 
export func1
export func2 
or 
export {func1,func2}
>> import {func1} from'./fileName.j  s'

u can export func or variable

4. class 


5. Spread Operators
1.Spread in Arrays:

Copying an Array:
const originalArray = [1, 2, 3];
const copiedArray = [...originalArray];

console.log(copiedArray); // Output: [1, 2, 3]


Concatenating Arrays:
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];
const concatenatedArray = [...array1, ...array2];
console.log(concatenatedArray); // Output: [1, 2, 3, 4, 5, 6]

const originalArray = [1, 2, 3];
const newArray = [...originalArray, 4, 5];

console.log(newArray); // Output: [1, 2, 3, 4, 5]

2. Spread in Objects:
const originalObject = { key1: 'value1', key2: 'value2' };
const copiedObject = { ...originalObject };

console.log(copiedObject); // Output: { key1: 'value1', key2: 'value2' }

const object1 = { key1: 'value1' };
const object2 = { key2: 'value2' };
const mergedObject = { ...object1, ...object2 };

console.log(mergedObject); // Output: { key1: 'value1', key2: 'value2' }

const originalObject = { key1: 'value1' };
const newObject = { ...originalObject, key2: 'value2' };

console.log(newObject); // Output: { key1: 'value1', key2: 'value2' }

  func goo 
const numbers = [1, 2, 32, 3, 4, 5,32,1];

  function sum(...args) {
    return args.reduce((acc, current) => acc + current, 100);
    // args.reduce((value ,define var to save into result the func) => value + result, inital value)
  }

  const result = sum(...numbers);
  console.log(result); // Output: 47

6. Destructuring 
array:
const arr = [1,5,2,3];
const [ , , x] = arr 
c.l(x) => 2
object : 
cosnt ob = {id:'1',name:'mhd'}
const {name} = ob ; ==> mhd
const {id} = ob; ==> 1
or 
const {name , id} = ob;

7.Primitive Types
  var ob1 = {id:'1'};
  var ob2 =  ob1;
  ob2.id = '100';
console.log(ob1.id); 
===> spread operation

14-Array Functions
const  items = items.map((item) => c.l(item))
const  items = items.map((item) => <li> {item} </li> )

15-Array Simple Methodes 
Slice,Splice,Reverse,Concat,Join ,
Fillter,Find,Sort,Reduce

Slice(1) تجاوز اول وحده 
دون تأثير ع اساسية 
اما splice ف تمحي من القديمة القيم المأخوذه
reverse : صف ل العكس وتأثر ع الاصلية
arr1.concat(arr2);
join >> اضافة محارف ل عناصر المصفوفة
const arr2 = arr1.sort((a,b) => 
                      {
                          if(a>b) a : قيمة , b القيمة التالية
                          return 1;  تركن متل ما هنن
                          if(b>a)
                          return -1 عكسن 
                      }); 



17-Higher Order Functions
These functions enable you to write more reusable and modular code by abstracting away common patterns and behaviors.


nodeJs is runtime js >> copmail js code on browser

______________________________________________________________________________________________________________________________
steal يسرق 
misuse it يسيء استخدامها
hence لذلك
long period 
brief period
compared 
Corresponding  ب المقابل

Referesh Token : 
Why do we need Refresh Tokens?
If we are using an access token for a long time, there is a chance a hacker can steal our token and misuse it. 
Hence it is not very safe to use the access token for a long period.

Refresh tokens are the kind of tokens that can be used to get new access tokens. When the access tokens expire,
we can use refresh tokens to get a new access token from the authentication controller.
The lifetime of a refresh token is usually much longer compared to the lifetime of an access token.

We will set a short lifetime for an access token. So that,
 even the access token used by a hacker gets access only for a brief period.
  We will issue a refresh token along with an access token from the login request.
   Whenever the access token expires, 
   we can get a new access token using the refresh token.

We will be using Microsoft Identity framework to store user and role information. 
ASP.NET Core Identity is a membership system which allows you to add login functionality to your application.
Users can create an account and login with a username and password, or they can use an external login provider such as Facebook,
 Google, Microsoft Account, Twitter and more.


 Whenever the user login into the application using valid credentials, 
 we will update refresh token and token expiry time in the user table inside the Identity database.
 After the expiry of access token, if user again tries to get secured resource from the application, Then the user can try to refresh the token using current access token and refresh token. 
 In the refresh method, application will confirm expired token and refresh token. If both are valid, 
 the application will issue a new access token and refresh token to the user.
 Corresponding user can use this new token to access secured resources in the application.


If something went wrong, the refresh token can be revoked which means that when the application tries to use it to get a new access token, 
that request will be rejected, and the user will have to enter credentials once again and authenticate.





---------------------------------------------------------------------------------


Typescript : 


2. array 

let nums : number[] = [1,2,3,4];
let names : string[] = ['ssad','mhd']

type [] ====> array 

let cars : [string , number, date] = ["car1", 22, new Date()];
let carsUp : [string | number] = [1,2,3,4,'ssada']
>> 

Generics :  ===>>> reuseable










 






































