Go PRo
"" 
Configure MongoDB
Create a MongoDB database
Define a MongoDB collection and schema
Perform MongoDB CRUD operations from a web API
Customize JSON serialization

""

1. install packages: 
dotnet new webapi -n CSharpCornerArticlesAPI
cd CSharpCornerArticlesAPI
dotnet add package MongoDB.Driver

2. Create Model 
First, let’s create models. Models describe how the data we manipulate should look like.

Add new folder, name it “Models”
Add a new class, name it “JobModel.cs”
Add a new class, name it “DatabaseSetting.cs”

public class JobModel
    {
        [BsonId]
        [BsonRepresentation(MongoDB.Bson.BsonType.ObjectId)]
        public string? Id { get; set; }
        public string Position { get; set; } = null!;
        public string? Requirement { get; set; }
        public string Company { get; set; } = null!;
        public string Location { get; set; } = null!;
        public string? Contact { get; set; }
        public string Email { get; set; } = null!;
        public string Date { get; set; } = DateTime.UtcNow.ToString();
        [BsonRepresentation(MongoDB.Bson.BsonType.DateTime)]
        public DateTime DateApplied => DateTime.Parse(Date);
        public string Status { get; set; } = "pending";
    }

Note : 
[BsonId] indicates the property as the primary key of the document.
[BsonRepresentation(MongoDB.Bson.BsonType.ObjectId] allows the property to be a string, and pass it to MongoDB to convert to ObjectId on its side.
Make sure using MongoDB.Bson.Serialization.Attributes to allow the above annotations.
<T>? indicates the property is nullable.
If the property is not nullable, attach = null!to indicate it must not be null or = <default_value>

3. DatabaseSetting.cs
Then, you will create the database configuration model, which contains the following 3 properties, all non nullable:

namespace JobTracker.Models
{
    public class DatabaseSetting
    {
        public string ConnectionString { get; set; } = null!;
        public string DatabaseName { get; set; } = null!;

        public string CollectionName { get; set; } = null!;
    }
}

4. AppSettings.json
{
// You can name the properties however you want as long as you are consistent
// You can find the connection string in Step 3 > Option B > Step 4-6
  "JobTrackerDatabase": { 
    "ConnectionString": <connection_string>,
    "DatabaseName": "JobTrackerDB",
    "CollectionName": "Jobs"
  },
  "Logging": {}}

5. Update Program.cs
builder.Services.Configure<DatabaseSetting>(builder.Configuration.GetSection("JobTrackerDatabase"));
note : builder.Services.Configure<Database_config_model>(<Database_config_value>)


6. Create Services for CRUD
 public class JobTrackerService
    {
        public readonly IMongoCollection<JobModel> _jobsCollection;

        public JobTrackerService(IOptions<DatabaseSetting> jobTrackerDatabaseSetting)
        {
            var mongoClient = new MongoClient(jobTrackerDatabaseSetting.Value.ConnectionString);
            var mongoDatabase = mongoClient.GetDatabase(jobTrackerDatabaseSetting.Value.DatabaseName);
            _jobsCollection = mongoDatabase.GetCollection<JobModel>(jobTrackerDatabaseSetting.Value.CollectionName);
        }

    } 


7. Create CRUD functions to interact with the database
public async Task<List<JobModel>> GetAllEntries() => 
  await _jobsCollection.Find(_ => true).ToListAsync();

public async Task<JobModel?> GetEntryById(string id) => 
  await _jobsCollection.Find(x => x.Id == id).FirstOrDefaultAsync();

public async Task<List<JobModel>> GetEntryByLocation(string location) => 
  await _jobsCollection.Find(x => x.Location == location).ToListAsync();

public async Task CreateEntry(JobModel newJob) => 
  await _jobsCollection.InsertOneAsync(newJob);

public async Task UpdateEntry(string id, JobModel updatedJob) => 
  await _jobsCollection.ReplaceOneAsync(x => x.Id == id, updatedJob);

public async Task RemoveEntry(string id) => 
  await _jobsCollection.DeleteOneAsync(x => x.Id == id)


8. STEP 4.5 — Update Program.cs
Let’s also register “JobTrackerService” in DI container so it can be accessed by other parts of the application. 
This time you use AddSingleton<TService>();

====>  builder.Services.AddSingleton<JobTrackerService>();

9. Add in Controller 

// api/jobs
    [HttpGet]
    public async Task<List<JobModel>> GetAll() => await _jobTrackerService.GetAllEntries();

    // api/jobs/{id}
    [HttpGet("{id:length(24)}")]
    public async Task<ActionResult<JobModel>> GetById(string id)
    {
        var job = await _jobTrackerService.GetEntryById(id);

        if (job == null)
        {
            return NotFound();
        }
        return job;
    }

    // api/jobs/filter?location={location}
    [HttpGet("filter")]
    public async Task<ActionResult<List<JobModel>>> GetByLocation(string location)
    {
        var jobList = await _jobTrackerService.GetEntryByLocation(location);
        if (jobList.Count == 0)
        {
            return NotFound();
        }
        return jobList;
    }

    // api/jobs
    [HttpPost]
    public async Task<IActionResult> Post(JobModel newJob)
    {
        await _jobTrackerService.CreateEntry(newJob);
        return CreatedAtAction(nameof(GetById), new {id = newJob.Id }, newJob);
    }

    // api/jobs/{id}
    [HttpPut("{id:length(24)}")]
    public async Task<IActionResult> Put(string id, JobModel updatedJob)
    {
        var job = await _jobTrackerService.GetEntryById(id);

        if (job is null)
        {
            return NotFound();
        }
        updatedJob.Id = job.Id;
        await _jobTrackerService.UpdateEntry(id, updatedJob);

        return NoContent();
    }

    // api/jobs/{id}
    [HttpDelete("{id:length(24)}")]
    public async Task<IActionResult> Delete(string id)
    {
        var job = await _jobTrackerService.GetEntryById(id);

        if (job is null)
        {
            return NotFound();
        }
        await _jobTrackerService.RemoveEntry(id);
        return NoContent();
    }


    Note : 
    ""
    _ All paths start with api/jobs because they are under the same controller base.
    _ They are asynchronous because of the interaction with database.
    _ Task<TResult> class type is used to represent an async operation which returns a value.
    _ Choose a proper TResult type, for example ActionResult, HttpResults, IActionResult. (For more details: https://learn.microsoft.com/en-us/aspnet/core/web-api/action-return-types?view=aspnetcore-7.0)
    _ Choose a proper data type for the return value, for example if it is a collection, you can choose List or IEnumerable.
    _ You can use NoContent(), NotFound(), Ok() to respond to various situations. 
    (BadRequest() should not be necessary as you have used ApiController Attribute on the top)

    ""
